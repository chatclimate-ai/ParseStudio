{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Parstudio Documentation","text":""},{"location":"#entry-point","title":"Entry Point","text":"<p>The entry point for the Parstudio library is the PDFParser module,  that acts as the main interface for the library. </p> <p>The PDFParser module initializes the parser and provides a method to parse a PDF file. Which could be either: - A DoclingParser - A PymuPDFParser - A LlmapParser</p> <p>To run the parser, you can use the <code>run</code> method of the PDFParser module.</p>"},{"location":"#documentation","title":"Documentation","text":""},{"location":"#parstudio.parse.PDFParser","title":"<code>PDFParser</code>","text":"<p>A class to parse PDF files using different parsers.</p> Source code in <code>parstudio/parse.py</code> <pre><code>class PDFParser:\n    \"\"\"\n    A class to parse PDF files using different parsers.\n    \"\"\"\n    def __init__(self, parser: Literal[\"docling\", \"llama\", \"pymupdf\"] = \"docling\"):\n        \"\"\"\n        Initialize the PDF parser with the specified parser.\n\n        Args:\n            parser (str): The parser to use. Options are 'docling' and 'llama', and 'pymupdf'. Defaults to 'docling'.\n\n        Raises:\n            ValueError: If an invalid parser is specified.\n        \"\"\"\n        if parser == \"docling\":\n            self.parser = DoclingPDFParser()\n        elif parser == \"llama\":\n            self.parser = LlamaPDFParser()\n        elif parser == \"pymupdf\":\n            self.parser = PyMuPDFParser()\n        else:\n            raise ValueError(\n                \"Invalid parser specified. Please use 'docling' or 'llama'.\"\n            )\n\n    def run(self, pdf_path: Union[str, List[str]], **kwargs) -&gt; List[ParserOutput]:\n        \"\"\"\n        Run the PDF parser on the given PDF file(s).\n\n        Args:\n            pdf_path (str or List[str]): The path to the PDF file(s) to parse.\n            **kwargs: Additional keyword arguments to pass to the parser.\n\n        Returns:\n            List[ParserOutput]: The parsed output(s) from the PDF file(s).\n\n        Examples:\n            &gt;&gt;&gt; parser = PDFParser(parser=\"docling\")\n            &gt;&gt;&gt; outputs = parser.run(\"path/to/file.pdf\", backend=\"docling\")\n        \"\"\"\n\n        outputs = self.parser.parse_and_export(pdf_path, **kwargs)\n\n        return outputs\n</code></pre>"},{"location":"#parstudio.parse.PDFParser.__init__","title":"<code>__init__(parser='docling')</code>","text":"<p>Initialize the PDF parser with the specified parser.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>str</code> <p>The parser to use. Options are 'docling' and 'llama', and 'pymupdf'. Defaults to 'docling'.</p> <code>'docling'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid parser is specified.</p> Source code in <code>parstudio/parse.py</code> <pre><code>def __init__(self, parser: Literal[\"docling\", \"llama\", \"pymupdf\"] = \"docling\"):\n    \"\"\"\n    Initialize the PDF parser with the specified parser.\n\n    Args:\n        parser (str): The parser to use. Options are 'docling' and 'llama', and 'pymupdf'. Defaults to 'docling'.\n\n    Raises:\n        ValueError: If an invalid parser is specified.\n    \"\"\"\n    if parser == \"docling\":\n        self.parser = DoclingPDFParser()\n    elif parser == \"llama\":\n        self.parser = LlamaPDFParser()\n    elif parser == \"pymupdf\":\n        self.parser = PyMuPDFParser()\n    else:\n        raise ValueError(\n            \"Invalid parser specified. Please use 'docling' or 'llama'.\"\n        )\n</code></pre>"},{"location":"#parstudio.parse.PDFParser.run","title":"<code>run(pdf_path, **kwargs)</code>","text":"<p>Run the PDF parser on the given PDF file(s).</p> <p>Parameters:</p> Name Type Description Default <code>pdf_path</code> <code>str or List[str]</code> <p>The path to the PDF file(s) to parse.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the parser.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[ParserOutput]</code> <p>List[ParserOutput]: The parsed output(s) from the PDF file(s).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; parser = PDFParser(parser=\"docling\")\n&gt;&gt;&gt; outputs = parser.run(\"path/to/file.pdf\", backend=\"docling\")\n</code></pre> Source code in <code>parstudio/parse.py</code> <pre><code>def run(self, pdf_path: Union[str, List[str]], **kwargs) -&gt; List[ParserOutput]:\n    \"\"\"\n    Run the PDF parser on the given PDF file(s).\n\n    Args:\n        pdf_path (str or List[str]): The path to the PDF file(s) to parse.\n        **kwargs: Additional keyword arguments to pass to the parser.\n\n    Returns:\n        List[ParserOutput]: The parsed output(s) from the PDF file(s).\n\n    Examples:\n        &gt;&gt;&gt; parser = PDFParser(parser=\"docling\")\n        &gt;&gt;&gt; outputs = parser.run(\"path/to/file.pdf\", backend=\"docling\")\n    \"\"\"\n\n    outputs = self.parser.parse_and_export(pdf_path, **kwargs)\n\n    return outputs\n</code></pre>"},{"location":"parsers/docling_parser/","title":"The Docling Parser","text":"<p>The Docling parser uses docling under the hood to parse pdfs and extract text from them. It is a simple wrapper around the docling library that provides a more user-friendly interface.</p>"},{"location":"parsers/docling_parser/#documentation","title":"Documentation","text":""},{"location":"parsers/docling_parser/#parstudio.parsers.docling_parser.DoclingPDFParser","title":"<code>DoclingPDFParser</code>","text":"<p>Parse a PDF file using the Docling Parser</p> Source code in <code>parstudio/parsers/docling_parser.py</code> <pre><code>class DoclingPDFParser:\n    \"\"\"\n    Parse a PDF file using the Docling Parser\n    \"\"\"\n\n    def __init__(self):\n        self.embed_images = None\n        self.initialized = False\n\n    def __initialize_docling(\n        self,\n        pipeline_options: PdfPipelineOptions,\n        backend: Union[DoclingParseDocumentBackend, PyPdfiumDocumentBackend],\n    ) -&gt; None:\n        \"\"\"\n        Initialize the DocumentConverter with the given pipeline options and backend.\n\n        Args:\n            pipeline_options (PdfPipelineOptions): The pipeline options to use for parsing the document\n            backend (Union[DoclingParseDocumentBackend, PyPdfiumDocumentBackend]): The backend to use for parsing the document\n\n        Returns:\n            None\n        \"\"\"\n        self.converter = DocumentConverter(\n            allowed_formats=[InputFormat.PDF],\n            format_options={\n                InputFormat.PDF: PdfFormatOption(\n                    pipeline_options=pipeline_options, backend=backend\n                )\n            },\n        )\n\n        self.initialized = True\n\n    def load_documents(\n        self, paths: List[str], **kwargs\n    ) -&gt; Generator[ConversionResult, None, None]:\n        \"\"\"\n        Load the given documents and parse them. The documents are parsed in parallel.\n\n        Args:\n            paths (List[str]): The list of paths to the documents to parse\n            raises_on_error (bool): Whether to raise an error if the document fails to parse. Default is True\n            max_num_pages (int): The maximum number of pages to parse. If the document has more pages, it will be skipped. Default is sys.maxsize\n            max_file_size (int): The maximum file size to parse. If the document is larger, it will be skipped. Default is sys.maxsize\n\n        Returns:\n            conversion_result (Generator[ConversionResult, None, None]): A generator that yields the parsed result for each document (file)\n\n        Raises:\n            ValueError: If the Docling Parser has not been initialized\n\n        Examples:\n            &gt;&gt;&gt; parser = DoclingPDFParser()\n            &gt;&gt;&gt; for result in parser.load_documents([\"path/to/file1.pdf\", \"path/to/file2.pdf\"]):\n            ...     if result.status == ConversionStatus.SUCCESS:\n            ...         print(result.document)\n            ...     else:\n            ...         print(result.errors)\n            ConversionResult(status=&lt;ConversionStatus.SUCCESS: 'SUCCESS'&gt;, document=&lt;DoclingDocument&gt;, errors=None)\n        \"\"\"\n        if not self.initialized:\n            raise ValueError(\"The Docling Parser has not been initialized.\")\n\n        raises_on_error = kwargs.get(\"raises_on_error\", True)\n        max_num_pages = kwargs.get(\"max_num_pages\", sys.maxsize)\n        max_file_size = kwargs.get(\"max_file_size\", sys.maxsize)\n\n        yield from self.converter.convert_all(\n            paths,\n            raises_on_error=raises_on_error,\n            max_num_pages=max_num_pages,\n            max_file_size=max_file_size,\n        )\n\n    def parse_and_export(\n        self,\n        paths: Union[str, List[str]],\n        modalities: List[str] = [\"text\", \"tables\", \"images\"],\n        **kwargs,\n    ) -&gt; List[ParserOutput]:\n        \"\"\"\n        Parse the given documents and export the parsed results in the specified modalities. The parsed results are exported as a ParserOutput object.\n\n        Args:\n            paths (Union[str, List[str]): The path(s) to the document(s) to parse\n            modalities (List[str]): The modalities to export the parsed results in (text, tables, images). Default is [\"text\", \"tables\", \"images\"]\n            do_ocr (bool): Whether to perform OCR on the document. Default is True.\n            ocr_options (str): The OCR options to use (easyocr, tesseract). Default is easyocr.\n            do_table_structure (bool): Whether to extract table structure from the document. Default is True.\n            do_cell_matching (bool): Whether to perform cell matching on the tables. Default is False.\n            tableformer_mode (str): The mode to use for extracting table structure (ACCURATE, FAST). Default is ACCURATE.\n            images_scale (float): The scale factor to apply to the images. Default is 1.0.\n            generate_page_images (bool): Whether to generate images for each page. Default is False.\n            generate_picture_images (bool): Whether to generate images for pictures. Default is True.\n            generate_table_images (bool): Whether to generate images for tables. Default is True.\n            backend (str): The backend to use for parsing the document (docling, pypdfium). Default is docling.\n            embed_images (bool): Whether to embed images in the exported text (markdown string). Default is True.\n\n        Returns:\n            data (List[ParserOutput]): A list of parsed results for the document(s)\n\n        Raises:\n            ValueError: If the OCR options specified are invalid\n            ValueError: If the mode specified for the tableformer is invalid\n            ValueError: If the backend specified is invalid\n\n        Examples:\n            &gt;&gt;&gt; parser = DoclingPDFParser()\n            &gt;&gt;&gt; data = parser.parse_and_export(\"path/to/file.pdf\", modalities=[\"text\", \"tables\", \"images\"])\n            &gt;&gt;&gt; print(data)\n            [ParserOutput(text=\"...\", tables=[{\"table_md\": \"...\", \"table_df\": pd.DataFrame}], images=[{\"image\": Image.Image}])]\n        \"\"\"\n        if isinstance(paths, str):\n            paths = [paths]\n\n        if not self.initialized:\n            # Set pipeline options\n            pipeline_options = PdfPipelineOptions()\n\n            # Set ocr options\n            pipeline_options.do_ocr = kwargs.get(\"do_ocr\", True)\n            ocr_options = kwargs.get(\"ocr_options\", \"easyocr\")\n            if ocr_options == \"easyocr\":\n                pipeline_options.ocr_options = EasyOcrOptions(\n                    use_gpu=False,\n                    lang=[\"en\"],\n                    # force_full_page_ocr=True,\n                )\n            elif ocr_options == \"tesseract\":\n                pipeline_options.ocr_options = TesseractOcrOptions(\n                    lang=\"eng\",\n                    # force_full_page_ocr=True,\n                )\n            else:\n                raise ValueError(f\"Invalid OCR options specified: {ocr_options}\")\n\n            # Set table structure options\n            pipeline_options.do_table_structure = kwargs.get(\"do_table_structure\", True)\n            pipeline_options.table_structure_options.do_cell_matching = kwargs.get(\n                \"do_cell_matching\", False\n            )\n            mode = kwargs.get(\"tableformer_mode\", \"ACCURATE\")\n            if mode == \"ACCURATE\":\n                pipeline_options.table_structure_options.mode = TableFormerMode.ACCURATE\n            elif mode == \"FAST\":\n                pipeline_options.table_structure_options.mode = TableFormerMode.FAST\n            else:\n                raise ValueError(f\"Invalid mode specified: {mode}\")\n\n            # Set image options\n            pipeline_options.images_scale = kwargs.get(\"images_scale\", 1.0)\n            pipeline_options.generate_page_images = kwargs.get(\n                \"generate_page_images\", False\n            )\n            pipeline_options.generate_picture_images = kwargs.get(\n                \"generate_picture_images\", True\n            )\n            pipeline_options.generate_table_images = kwargs.get(\n                \"generate_table_images\", True\n            )\n\n            # Set backend\n            backend = kwargs.get(\"backend\", \"docling\")\n            if backend == \"docling\":\n                backend = DoclingParseDocumentBackend\n            elif backend == \"pypdfium\":\n                backend = PyPdfiumDocumentBackend\n            else:\n                raise ValueError(f\"Invalid backend specified: {backend}\")\n\n            self.embed_images = kwargs.get(\"embed_images\", True)\n\n            # Initialize the Docling Parser\n            self.__initialize_docling(pipeline_options, backend)\n\n        data = []\n        for result in self.load_documents(paths, **kwargs):\n            if result.status == ConversionStatus.SUCCESS:\n                output = self.__export_result(result.document, modalities)\n\n                data.append(output)\n\n            else:\n                raise ValueError(f\"Failed to parse the document: {result.errors}\")\n        return data\n\n    def __export_result(\n        self, document: DoclingDocument, modalities: List[str]\n    ) -&gt; ParserOutput:\n        \"\"\"\n        Export the parsed results in a ParserOutput object for the given document.\n\n        Args:\n            document (DoclingDocument): The document to export\n            modalities (List[str]): The modalities to export the parsed results in (text, tables, images)\n\n        Returns:\n            output (ParserOutput): The parsed results for the document\n        \"\"\"\n        text = \"\"\n        tables: List[Dict] = []\n        images: List[Dict] = []\n\n        if \"text\" in modalities:\n            text = self._extract_text(document)\n\n        if any(modality in modalities for modality in [\"tables\", \"images\"]):\n            for item, _ in document.iterate_items():\n                if \"tables\" in modalities and isinstance(item, TableItem):\n                    tables += self._extract_tables(item)\n\n                if \"images\" in modalities and isinstance(item, PictureItem):\n                    images += self._extract_images(item)\n\n        return ParserOutput(text=text, tables=tables, images=images)\n\n    @staticmethod\n    def _extract_tables(item: TableItem) -&gt; List[Dict]:\n        \"\"\"\n        Extract tables from the document and return as a list of dictionaries with table markdown and dataframe data.\n\n        Args:\n            item (TableItem): The table item to extract\n\n        Returns:\n            tables (List[Dict]): A list of dictionaries with table data. Each dictionary contains a markdown table (table_md) and a pandas dataframe (table_df).\n\n        Examples:\n            &gt;&gt;&gt; tables = self._extract_tables(item)\n            &gt;&gt;&gt; print(tables)\n            [{\"table_md\": \"...\", \"table_df\": pd.DataFrame}]\n        \"\"\"\n        table_md: str = item.export_to_markdown()\n        table_df: pd.DataFrame = item.export_to_dataframe()\n\n        return [{\"table_md\": table_md, \"table_df\": table_df}]\n\n    @staticmethod\n    def _extract_images(item: PictureItem) -&gt; List[Dict]:\n        \"\"\"\n        Extract images from the document and return as a list of dictionaries with image data.\n\n        Args:\n            item (PictureItem): The picture item to extract\n\n        Returns:\n            images (List[Dict]): A list of dictionaries with image data. Each dictionary contains the image data as a PIL Image object.\n        \"\"\"\n        image: Image.Image = item.image.pil_image\n        return [{\"image\": image}]\n\n    def _extract_text(self, item: DoclingDocument) -&gt; str:\n        \"\"\"\n        Extract text from the document and return as a markdown string.\n\n        Args:\n            item (DoclingDocument): The document to extract text from\n\n        Returns:\n            text (str): The text extracted from the document as a markdown string. If embed_images is True, the images are embedded in the text. Otherwise, the images are replaced with the image placeholder (&lt;!-- image --&gt;).\n        \"\"\"\n        if self.embed_images:\n            return item.export_to_markdown(\n                image_mode=ImageRefMode.EMBEDDED,\n            )\n\n        return item.export_to_markdown(\n            image_mode=ImageRefMode.PLACEHOLDER,\n        )\n</code></pre>"},{"location":"parsers/docling_parser/#parstudio.parsers.docling_parser.DoclingPDFParser.__export_result","title":"<code>__export_result(document, modalities)</code>","text":"<p>Export the parsed results in a ParserOutput object for the given document.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>DoclingDocument</code> <p>The document to export</p> required <code>modalities</code> <code>List[str]</code> <p>The modalities to export the parsed results in (text, tables, images)</p> required <p>Returns:</p> Name Type Description <code>output</code> <code>ParserOutput</code> <p>The parsed results for the document</p> Source code in <code>parstudio/parsers/docling_parser.py</code> <pre><code>def __export_result(\n    self, document: DoclingDocument, modalities: List[str]\n) -&gt; ParserOutput:\n    \"\"\"\n    Export the parsed results in a ParserOutput object for the given document.\n\n    Args:\n        document (DoclingDocument): The document to export\n        modalities (List[str]): The modalities to export the parsed results in (text, tables, images)\n\n    Returns:\n        output (ParserOutput): The parsed results for the document\n    \"\"\"\n    text = \"\"\n    tables: List[Dict] = []\n    images: List[Dict] = []\n\n    if \"text\" in modalities:\n        text = self._extract_text(document)\n\n    if any(modality in modalities for modality in [\"tables\", \"images\"]):\n        for item, _ in document.iterate_items():\n            if \"tables\" in modalities and isinstance(item, TableItem):\n                tables += self._extract_tables(item)\n\n            if \"images\" in modalities and isinstance(item, PictureItem):\n                images += self._extract_images(item)\n\n    return ParserOutput(text=text, tables=tables, images=images)\n</code></pre>"},{"location":"parsers/docling_parser/#parstudio.parsers.docling_parser.DoclingPDFParser.__initialize_docling","title":"<code>__initialize_docling(pipeline_options, backend)</code>","text":"<p>Initialize the DocumentConverter with the given pipeline options and backend.</p> <p>Parameters:</p> Name Type Description Default <code>pipeline_options</code> <code>PdfPipelineOptions</code> <p>The pipeline options to use for parsing the document</p> required <code>backend</code> <code>Union[DoclingParseDocumentBackend, PyPdfiumDocumentBackend]</code> <p>The backend to use for parsing the document</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>parstudio/parsers/docling_parser.py</code> <pre><code>def __initialize_docling(\n    self,\n    pipeline_options: PdfPipelineOptions,\n    backend: Union[DoclingParseDocumentBackend, PyPdfiumDocumentBackend],\n) -&gt; None:\n    \"\"\"\n    Initialize the DocumentConverter with the given pipeline options and backend.\n\n    Args:\n        pipeline_options (PdfPipelineOptions): The pipeline options to use for parsing the document\n        backend (Union[DoclingParseDocumentBackend, PyPdfiumDocumentBackend]): The backend to use for parsing the document\n\n    Returns:\n        None\n    \"\"\"\n    self.converter = DocumentConverter(\n        allowed_formats=[InputFormat.PDF],\n        format_options={\n            InputFormat.PDF: PdfFormatOption(\n                pipeline_options=pipeline_options, backend=backend\n            )\n        },\n    )\n\n    self.initialized = True\n</code></pre>"},{"location":"parsers/docling_parser/#parstudio.parsers.docling_parser.DoclingPDFParser.load_documents","title":"<code>load_documents(paths, **kwargs)</code>","text":"<p>Load the given documents and parse them. The documents are parsed in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>List[str]</code> <p>The list of paths to the documents to parse</p> required <code>raises_on_error</code> <code>bool</code> <p>Whether to raise an error if the document fails to parse. Default is True</p> required <code>max_num_pages</code> <code>int</code> <p>The maximum number of pages to parse. If the document has more pages, it will be skipped. Default is sys.maxsize</p> required <code>max_file_size</code> <code>int</code> <p>The maximum file size to parse. If the document is larger, it will be skipped. Default is sys.maxsize</p> required <p>Returns:</p> Name Type Description <code>conversion_result</code> <code>Generator[ConversionResult, None, None]</code> <p>A generator that yields the parsed result for each document (file)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the Docling Parser has not been initialized</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; parser = DoclingPDFParser()\n&gt;&gt;&gt; for result in parser.load_documents([\"path/to/file1.pdf\", \"path/to/file2.pdf\"]):\n...     if result.status == ConversionStatus.SUCCESS:\n...         print(result.document)\n...     else:\n...         print(result.errors)\nConversionResult(status=&lt;ConversionStatus.SUCCESS: 'SUCCESS'&gt;, document=&lt;DoclingDocument&gt;, errors=None)\n</code></pre> Source code in <code>parstudio/parsers/docling_parser.py</code> <pre><code>def load_documents(\n    self, paths: List[str], **kwargs\n) -&gt; Generator[ConversionResult, None, None]:\n    \"\"\"\n    Load the given documents and parse them. The documents are parsed in parallel.\n\n    Args:\n        paths (List[str]): The list of paths to the documents to parse\n        raises_on_error (bool): Whether to raise an error if the document fails to parse. Default is True\n        max_num_pages (int): The maximum number of pages to parse. If the document has more pages, it will be skipped. Default is sys.maxsize\n        max_file_size (int): The maximum file size to parse. If the document is larger, it will be skipped. Default is sys.maxsize\n\n    Returns:\n        conversion_result (Generator[ConversionResult, None, None]): A generator that yields the parsed result for each document (file)\n\n    Raises:\n        ValueError: If the Docling Parser has not been initialized\n\n    Examples:\n        &gt;&gt;&gt; parser = DoclingPDFParser()\n        &gt;&gt;&gt; for result in parser.load_documents([\"path/to/file1.pdf\", \"path/to/file2.pdf\"]):\n        ...     if result.status == ConversionStatus.SUCCESS:\n        ...         print(result.document)\n        ...     else:\n        ...         print(result.errors)\n        ConversionResult(status=&lt;ConversionStatus.SUCCESS: 'SUCCESS'&gt;, document=&lt;DoclingDocument&gt;, errors=None)\n    \"\"\"\n    if not self.initialized:\n        raise ValueError(\"The Docling Parser has not been initialized.\")\n\n    raises_on_error = kwargs.get(\"raises_on_error\", True)\n    max_num_pages = kwargs.get(\"max_num_pages\", sys.maxsize)\n    max_file_size = kwargs.get(\"max_file_size\", sys.maxsize)\n\n    yield from self.converter.convert_all(\n        paths,\n        raises_on_error=raises_on_error,\n        max_num_pages=max_num_pages,\n        max_file_size=max_file_size,\n    )\n</code></pre>"},{"location":"parsers/docling_parser/#parstudio.parsers.docling_parser.DoclingPDFParser.parse_and_export","title":"<code>parse_and_export(paths, modalities=['text', 'tables', 'images'], **kwargs)</code>","text":"<p>Parse the given documents and export the parsed results in the specified modalities. The parsed results are exported as a ParserOutput object.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>Union[str, List[str]</code> <p>The path(s) to the document(s) to parse</p> required <code>modalities</code> <code>List[str]</code> <p>The modalities to export the parsed results in (text, tables, images). Default is [\"text\", \"tables\", \"images\"]</p> <code>['text', 'tables', 'images']</code> <code>do_ocr</code> <code>bool</code> <p>Whether to perform OCR on the document. Default is True.</p> required <code>ocr_options</code> <code>str</code> <p>The OCR options to use (easyocr, tesseract). Default is easyocr.</p> required <code>do_table_structure</code> <code>bool</code> <p>Whether to extract table structure from the document. Default is True.</p> required <code>do_cell_matching</code> <code>bool</code> <p>Whether to perform cell matching on the tables. Default is False.</p> required <code>tableformer_mode</code> <code>str</code> <p>The mode to use for extracting table structure (ACCURATE, FAST). Default is ACCURATE.</p> required <code>images_scale</code> <code>float</code> <p>The scale factor to apply to the images. Default is 1.0.</p> required <code>generate_page_images</code> <code>bool</code> <p>Whether to generate images for each page. Default is False.</p> required <code>generate_picture_images</code> <code>bool</code> <p>Whether to generate images for pictures. Default is True.</p> required <code>generate_table_images</code> <code>bool</code> <p>Whether to generate images for tables. Default is True.</p> required <code>backend</code> <code>str</code> <p>The backend to use for parsing the document (docling, pypdfium). Default is docling.</p> required <code>embed_images</code> <code>bool</code> <p>Whether to embed images in the exported text (markdown string). Default is True.</p> required <p>Returns:</p> Name Type Description <code>data</code> <code>List[ParserOutput]</code> <p>A list of parsed results for the document(s)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the OCR options specified are invalid</p> <code>ValueError</code> <p>If the mode specified for the tableformer is invalid</p> <code>ValueError</code> <p>If the backend specified is invalid</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; parser = DoclingPDFParser()\n&gt;&gt;&gt; data = parser.parse_and_export(\"path/to/file.pdf\", modalities=[\"text\", \"tables\", \"images\"])\n&gt;&gt;&gt; print(data)\n[ParserOutput(text=\"...\", tables=[{\"table_md\": \"...\", \"table_df\": pd.DataFrame}], images=[{\"image\": Image.Image}])]\n</code></pre> Source code in <code>parstudio/parsers/docling_parser.py</code> <pre><code>def parse_and_export(\n    self,\n    paths: Union[str, List[str]],\n    modalities: List[str] = [\"text\", \"tables\", \"images\"],\n    **kwargs,\n) -&gt; List[ParserOutput]:\n    \"\"\"\n    Parse the given documents and export the parsed results in the specified modalities. The parsed results are exported as a ParserOutput object.\n\n    Args:\n        paths (Union[str, List[str]): The path(s) to the document(s) to parse\n        modalities (List[str]): The modalities to export the parsed results in (text, tables, images). Default is [\"text\", \"tables\", \"images\"]\n        do_ocr (bool): Whether to perform OCR on the document. Default is True.\n        ocr_options (str): The OCR options to use (easyocr, tesseract). Default is easyocr.\n        do_table_structure (bool): Whether to extract table structure from the document. Default is True.\n        do_cell_matching (bool): Whether to perform cell matching on the tables. Default is False.\n        tableformer_mode (str): The mode to use for extracting table structure (ACCURATE, FAST). Default is ACCURATE.\n        images_scale (float): The scale factor to apply to the images. Default is 1.0.\n        generate_page_images (bool): Whether to generate images for each page. Default is False.\n        generate_picture_images (bool): Whether to generate images for pictures. Default is True.\n        generate_table_images (bool): Whether to generate images for tables. Default is True.\n        backend (str): The backend to use for parsing the document (docling, pypdfium). Default is docling.\n        embed_images (bool): Whether to embed images in the exported text (markdown string). Default is True.\n\n    Returns:\n        data (List[ParserOutput]): A list of parsed results for the document(s)\n\n    Raises:\n        ValueError: If the OCR options specified are invalid\n        ValueError: If the mode specified for the tableformer is invalid\n        ValueError: If the backend specified is invalid\n\n    Examples:\n        &gt;&gt;&gt; parser = DoclingPDFParser()\n        &gt;&gt;&gt; data = parser.parse_and_export(\"path/to/file.pdf\", modalities=[\"text\", \"tables\", \"images\"])\n        &gt;&gt;&gt; print(data)\n        [ParserOutput(text=\"...\", tables=[{\"table_md\": \"...\", \"table_df\": pd.DataFrame}], images=[{\"image\": Image.Image}])]\n    \"\"\"\n    if isinstance(paths, str):\n        paths = [paths]\n\n    if not self.initialized:\n        # Set pipeline options\n        pipeline_options = PdfPipelineOptions()\n\n        # Set ocr options\n        pipeline_options.do_ocr = kwargs.get(\"do_ocr\", True)\n        ocr_options = kwargs.get(\"ocr_options\", \"easyocr\")\n        if ocr_options == \"easyocr\":\n            pipeline_options.ocr_options = EasyOcrOptions(\n                use_gpu=False,\n                lang=[\"en\"],\n                # force_full_page_ocr=True,\n            )\n        elif ocr_options == \"tesseract\":\n            pipeline_options.ocr_options = TesseractOcrOptions(\n                lang=\"eng\",\n                # force_full_page_ocr=True,\n            )\n        else:\n            raise ValueError(f\"Invalid OCR options specified: {ocr_options}\")\n\n        # Set table structure options\n        pipeline_options.do_table_structure = kwargs.get(\"do_table_structure\", True)\n        pipeline_options.table_structure_options.do_cell_matching = kwargs.get(\n            \"do_cell_matching\", False\n        )\n        mode = kwargs.get(\"tableformer_mode\", \"ACCURATE\")\n        if mode == \"ACCURATE\":\n            pipeline_options.table_structure_options.mode = TableFormerMode.ACCURATE\n        elif mode == \"FAST\":\n            pipeline_options.table_structure_options.mode = TableFormerMode.FAST\n        else:\n            raise ValueError(f\"Invalid mode specified: {mode}\")\n\n        # Set image options\n        pipeline_options.images_scale = kwargs.get(\"images_scale\", 1.0)\n        pipeline_options.generate_page_images = kwargs.get(\n            \"generate_page_images\", False\n        )\n        pipeline_options.generate_picture_images = kwargs.get(\n            \"generate_picture_images\", True\n        )\n        pipeline_options.generate_table_images = kwargs.get(\n            \"generate_table_images\", True\n        )\n\n        # Set backend\n        backend = kwargs.get(\"backend\", \"docling\")\n        if backend == \"docling\":\n            backend = DoclingParseDocumentBackend\n        elif backend == \"pypdfium\":\n            backend = PyPdfiumDocumentBackend\n        else:\n            raise ValueError(f\"Invalid backend specified: {backend}\")\n\n        self.embed_images = kwargs.get(\"embed_images\", True)\n\n        # Initialize the Docling Parser\n        self.__initialize_docling(pipeline_options, backend)\n\n    data = []\n    for result in self.load_documents(paths, **kwargs):\n        if result.status == ConversionStatus.SUCCESS:\n            output = self.__export_result(result.document, modalities)\n\n            data.append(output)\n\n        else:\n            raise ValueError(f\"Failed to parse the document: {result.errors}\")\n    return data\n</code></pre>"},{"location":"parsers/llama_parser/","title":"The Llama Parser","text":"<p>The Llama parser uses llama under the hood to parse pdfs and extract text from them. It is a simple wrapper around the llama library that provides a more user-friendly interface.</p>"},{"location":"parsers/llama_parser/#documentation","title":"Documentation","text":""},{"location":"parsers/llama_parser/#parstudio.parsers.llama_parser.LlamaPDFParser","title":"<code>LlamaPDFParser</code>","text":"<p>Parse a PDF file using the LlamaParse library.</p> Source code in <code>parstudio/parsers/llama_parser.py</code> <pre><code>class LlamaPDFParser:\n    \"\"\"\n    Parse a PDF file using the LlamaParse library.\n    \"\"\"\n    def __init__(self):\n        self.initialized = False\n\n    def __initialize_llama(self, **kwargs) -&gt; None:\n        \"\"\"\n        Initialize the LlamaParse converter with the given options.\n\n        Args:\n            language (str): The language of the document. Default is \"en\".\n            result_type (str): The type of result to return. Default is \"markdown\".\n            continuous_mode (bool): Whether to use continuous mode while parsing. Default is True.\n            take_screenshot (bool): Whether to take screenshots of the document pages. Default is False.\n            disable_ocr (bool): Whether to disable OCR. Default is False.\n            is_formatting_instruction (bool): Whether to use the formatting instruction. Default is False.\n            show_progress (bool): Whether to show progress bar. Default is False.\n            ignore_errors (bool): Whether to ignore errors while parsing. Default is False.\n            split_by_page (bool): Whether to split the results by page or not. Default is False.\n            invalidate_cache (bool): Whether to invalidate the cache. Default is False.\n            do_not_cache (bool): Whether to not cache the results. Default is False.\n        \"\"\"\n        try:\n            self.converter = LlamaParse(\n                api_key=os.environ.get(\"LLAMA_PARSE_KEY\"),\n                show_progress=False,\n                ignore_errors=False,\n                split_by_page = False,\n                invalidate_cache=True,\n                do_not_cache=True,\n                **kwargs,\n            )\n\n            self.initialized = True\n\n        except Exception as e:\n            raise ValueError(\n                f\"An error occurred while initializing the LlamaParse converter: {e}\"\n            )\n\n    def load_documents(self, paths: List[str]) -&gt; Generator[Dict, None, None]:\n        \"\"\"\n        Load the given documents and parse them. The documents are parsed in parallel.\n\n        Args:\n            paths (List[str]): The list of paths to the PDF files.\n\n        Returns:\n            documents (Generator[Dict, None, None]): A generator that yields the parsed documents.\n        \"\"\"\n        if not self.initialized:\n            raise ValueError(\"The Docling Parser has not been initialized.\")\n\n        if isinstance(paths, str):\n            paths = [paths]\n\n        for path in paths:\n            if not os.path.exists(path):\n                raise FileNotFoundError(f\"The file {path} does not exist.\")\n\n            if not path.endswith(\".pdf\"):\n                raise ValueError(f\"The file {path} must be a PDF file.\")\n\n        document: List[Dict] = self.converter.get_json_result(paths)\n        yield from document\n\n    def parse_and_export(\n        self,\n        paths: Union[str, List[str]],\n        modalities: List[str] = [\"text\", \"tables\", \"images\"],\n        **kwargs,\n    ) -&gt; List[ParserOutput]:\n        \"\"\"\n        Parse the given documents and export the parsed results in the specified modalities. The parsed results are exported as a ParserOutput object.\n\n        Args:\n            paths (Union[str, List[str]]): The path to the PDF file or a list of paths to the PDF files.\n            modalities (List[str]): The list of modalities to export. Default is [\"text\", \"tables\", \"images\"].\n            language (str): The language of the document. Default is \"en\".\n            result_type (str): The type of result to return. Default is \"markdown\".\n            continuous_mode (bool): Whether to use continuous mode while parsing. Default is True.\n            take_screenshot (bool): Whether to take screenshots of the document pages. Default is False.\n            disable_ocr (bool): Whether to disable OCR. Default is False.\n            is_formatting_instruction (bool): Whether to use the formatting instruction. Default is False.\n\n        Returns:\n            data (List[ParserOutput]): A list of ParserOutput objects containing the parsed results.\n\n\n        Examples:\n            &gt;&gt;&gt; parser = LlamaPDFParser()\n            &gt;&gt;&gt; data = parser.parse_and_export(\"path/to/pdf/file.pdf\", modalities=[\"text\", \"tables\", \"images\"])\n            &gt;&gt;&gt; print(data)\n            [ParserOutput(text=\"...\", tables=[...], images=[...])]\n\n        \"\"\"\n        if isinstance(paths, str):\n            paths = [paths]\n\n        if not self.initialized:\n            language = kwargs.get(\"language\", \"en\")\n            result_type = kwargs.get(\"result_type\", \"markdown\")\n            continuous_mode = kwargs.get(\"continuous_mode\", True)\n            take_screenshot = kwargs.get(\"take_screenshot\", False)\n            disable_ocr = kwargs.get(\"disable_ocr\", False)\n            is_formatting_instruction = kwargs.get(\"is_formatting_instruction\", False)\n\n            self.__initialize_llama(\n                language=language,\n                result_type=result_type,\n                continuous_mode=continuous_mode,\n                take_screenshot=take_screenshot,\n                disable_ocr=disable_ocr,\n                is_formatting_instruction=is_formatting_instruction,\n            )\n\n        data = []\n        for result in self.load_documents(paths):\n            output = self.__export_result(result, modalities)\n            data.append(output)\n\n        return data\n\n    def __export_result(self, json_result: dict, modalities: List[str]) -&gt; ParserOutput:\n        \"\"\"\n        Export the parsed result for a given document to the ParserOutput schema.\n\n        Args:\n            json_result (dict): The parsed result of the document.\n            modalities (List[str]): The list of modalities to export.\n\n        Returns:\n            output (ParserOutput): The parsed result exported as a ParserOutput object.\n        \"\"\"\n        text = \"\"\n        tables: List[Dict] = []\n        images: List[Dict] = []\n\n        pages: List[Dict] = json_result[\"pages\"]\n\n        for page in pages:\n            if \"text\" in modalities:\n                text += self._extract_text(page) + \"\\n\"\n\n            if \"tables\" in modalities:\n                tables += self._extract_tables(page)\n\n            if \"images\" in modalities:\n                images += self._extract_images(page)\n\n        return ParserOutput(text=text, tables=tables, images=images)\n\n    @staticmethod\n    def _extract_text(page: Dict) -&gt; str:\n        \"\"\"\n        Extract text from a page.\n\n        Args:\n            page (Dict): The page dictionary containing the text data.\n\n        Returns:\n            text (str): The extracted text from the page.\n        \"\"\"\n        return page[\"text\"]\n\n    @staticmethod\n    def _extract_tables(page: Dict) -&gt; List[Dict]:\n        \"\"\"\n        Extract tables from the document and return as a list of dictionaries with with table markdown and dataframe data.\n\n        Args:\n            page (Dict): The page dictionary containing the table data.\n\n        Returns:\n            tables (List[Dict]): A list of dictionaries with table data. Each dictionary contains a markdown table (table_md) and a pandas dataframe (table_df).\n        \"\"\"\n        tables = []\n        for item in page[\"items\"]:\n            if item[\"type\"] == \"table\":\n                table_md = item[\"md\"]\n                table_df = pd.read_csv(io.StringIO(item[\"csv\"]), sep=\",\")\n\n                tables.append({\"table_md\": table_md, \"table_df\": table_df})\n        return tables\n\n    def _extract_images(self, page: Dict) -&gt; List[Dict]:\n        \"\"\"\n        Extract images from a page and return as a list of dictionaries with image data.\n\n        Args:\n            page (Dict): The page dictionary containing the image data.\n\n        Returns:\n            images (List[Dict]): A list of dictionaries with image data. Each dictionary contains the key \"image\" with the value as a PIL Image object.\n        \"\"\"\n        images = []\n        image_dicts = self.converter.get_images([page], download_path=\"llama_images\")\n        for img in image_dicts:\n            image_path = img[\"path\"]\n            image = Image.open(image_path).convert(\"RGB\")\n            images.append({\"image\": image})\n            os.remove(image_path)\n        return images\n</code></pre>"},{"location":"parsers/llama_parser/#parstudio.parsers.llama_parser.LlamaPDFParser.__export_result","title":"<code>__export_result(json_result, modalities)</code>","text":"<p>Export the parsed result for a given document to the ParserOutput schema.</p> <p>Parameters:</p> Name Type Description Default <code>json_result</code> <code>dict</code> <p>The parsed result of the document.</p> required <code>modalities</code> <code>List[str]</code> <p>The list of modalities to export.</p> required <p>Returns:</p> Name Type Description <code>output</code> <code>ParserOutput</code> <p>The parsed result exported as a ParserOutput object.</p> Source code in <code>parstudio/parsers/llama_parser.py</code> <pre><code>def __export_result(self, json_result: dict, modalities: List[str]) -&gt; ParserOutput:\n    \"\"\"\n    Export the parsed result for a given document to the ParserOutput schema.\n\n    Args:\n        json_result (dict): The parsed result of the document.\n        modalities (List[str]): The list of modalities to export.\n\n    Returns:\n        output (ParserOutput): The parsed result exported as a ParserOutput object.\n    \"\"\"\n    text = \"\"\n    tables: List[Dict] = []\n    images: List[Dict] = []\n\n    pages: List[Dict] = json_result[\"pages\"]\n\n    for page in pages:\n        if \"text\" in modalities:\n            text += self._extract_text(page) + \"\\n\"\n\n        if \"tables\" in modalities:\n            tables += self._extract_tables(page)\n\n        if \"images\" in modalities:\n            images += self._extract_images(page)\n\n    return ParserOutput(text=text, tables=tables, images=images)\n</code></pre>"},{"location":"parsers/llama_parser/#parstudio.parsers.llama_parser.LlamaPDFParser.__initialize_llama","title":"<code>__initialize_llama(**kwargs)</code>","text":"<p>Initialize the LlamaParse converter with the given options.</p> <p>Parameters:</p> Name Type Description Default <code>language</code> <code>str</code> <p>The language of the document. Default is \"en\".</p> required <code>result_type</code> <code>str</code> <p>The type of result to return. Default is \"markdown\".</p> required <code>continuous_mode</code> <code>bool</code> <p>Whether to use continuous mode while parsing. Default is True.</p> required <code>take_screenshot</code> <code>bool</code> <p>Whether to take screenshots of the document pages. Default is False.</p> required <code>disable_ocr</code> <code>bool</code> <p>Whether to disable OCR. Default is False.</p> required <code>is_formatting_instruction</code> <code>bool</code> <p>Whether to use the formatting instruction. Default is False.</p> required <code>show_progress</code> <code>bool</code> <p>Whether to show progress bar. Default is False.</p> required <code>ignore_errors</code> <code>bool</code> <p>Whether to ignore errors while parsing. Default is False.</p> required <code>split_by_page</code> <code>bool</code> <p>Whether to split the results by page or not. Default is False.</p> required <code>invalidate_cache</code> <code>bool</code> <p>Whether to invalidate the cache. Default is False.</p> required <code>do_not_cache</code> <code>bool</code> <p>Whether to not cache the results. Default is False.</p> required Source code in <code>parstudio/parsers/llama_parser.py</code> <pre><code>def __initialize_llama(self, **kwargs) -&gt; None:\n    \"\"\"\n    Initialize the LlamaParse converter with the given options.\n\n    Args:\n        language (str): The language of the document. Default is \"en\".\n        result_type (str): The type of result to return. Default is \"markdown\".\n        continuous_mode (bool): Whether to use continuous mode while parsing. Default is True.\n        take_screenshot (bool): Whether to take screenshots of the document pages. Default is False.\n        disable_ocr (bool): Whether to disable OCR. Default is False.\n        is_formatting_instruction (bool): Whether to use the formatting instruction. Default is False.\n        show_progress (bool): Whether to show progress bar. Default is False.\n        ignore_errors (bool): Whether to ignore errors while parsing. Default is False.\n        split_by_page (bool): Whether to split the results by page or not. Default is False.\n        invalidate_cache (bool): Whether to invalidate the cache. Default is False.\n        do_not_cache (bool): Whether to not cache the results. Default is False.\n    \"\"\"\n    try:\n        self.converter = LlamaParse(\n            api_key=os.environ.get(\"LLAMA_PARSE_KEY\"),\n            show_progress=False,\n            ignore_errors=False,\n            split_by_page = False,\n            invalidate_cache=True,\n            do_not_cache=True,\n            **kwargs,\n        )\n\n        self.initialized = True\n\n    except Exception as e:\n        raise ValueError(\n            f\"An error occurred while initializing the LlamaParse converter: {e}\"\n        )\n</code></pre>"},{"location":"parsers/llama_parser/#parstudio.parsers.llama_parser.LlamaPDFParser.load_documents","title":"<code>load_documents(paths)</code>","text":"<p>Load the given documents and parse them. The documents are parsed in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>List[str]</code> <p>The list of paths to the PDF files.</p> required <p>Returns:</p> Name Type Description <code>documents</code> <code>Generator[Dict, None, None]</code> <p>A generator that yields the parsed documents.</p> Source code in <code>parstudio/parsers/llama_parser.py</code> <pre><code>def load_documents(self, paths: List[str]) -&gt; Generator[Dict, None, None]:\n    \"\"\"\n    Load the given documents and parse them. The documents are parsed in parallel.\n\n    Args:\n        paths (List[str]): The list of paths to the PDF files.\n\n    Returns:\n        documents (Generator[Dict, None, None]): A generator that yields the parsed documents.\n    \"\"\"\n    if not self.initialized:\n        raise ValueError(\"The Docling Parser has not been initialized.\")\n\n    if isinstance(paths, str):\n        paths = [paths]\n\n    for path in paths:\n        if not os.path.exists(path):\n            raise FileNotFoundError(f\"The file {path} does not exist.\")\n\n        if not path.endswith(\".pdf\"):\n            raise ValueError(f\"The file {path} must be a PDF file.\")\n\n    document: List[Dict] = self.converter.get_json_result(paths)\n    yield from document\n</code></pre>"},{"location":"parsers/llama_parser/#parstudio.parsers.llama_parser.LlamaPDFParser.parse_and_export","title":"<code>parse_and_export(paths, modalities=['text', 'tables', 'images'], **kwargs)</code>","text":"<p>Parse the given documents and export the parsed results in the specified modalities. The parsed results are exported as a ParserOutput object.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>Union[str, List[str]]</code> <p>The path to the PDF file or a list of paths to the PDF files.</p> required <code>modalities</code> <code>List[str]</code> <p>The list of modalities to export. Default is [\"text\", \"tables\", \"images\"].</p> <code>['text', 'tables', 'images']</code> <code>language</code> <code>str</code> <p>The language of the document. Default is \"en\".</p> required <code>result_type</code> <code>str</code> <p>The type of result to return. Default is \"markdown\".</p> required <code>continuous_mode</code> <code>bool</code> <p>Whether to use continuous mode while parsing. Default is True.</p> required <code>take_screenshot</code> <code>bool</code> <p>Whether to take screenshots of the document pages. Default is False.</p> required <code>disable_ocr</code> <code>bool</code> <p>Whether to disable OCR. Default is False.</p> required <code>is_formatting_instruction</code> <code>bool</code> <p>Whether to use the formatting instruction. Default is False.</p> required <p>Returns:</p> Name Type Description <code>data</code> <code>List[ParserOutput]</code> <p>A list of ParserOutput objects containing the parsed results.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; parser = LlamaPDFParser()\n&gt;&gt;&gt; data = parser.parse_and_export(\"path/to/pdf/file.pdf\", modalities=[\"text\", \"tables\", \"images\"])\n&gt;&gt;&gt; print(data)\n[ParserOutput(text=\"...\", tables=[...], images=[...])]\n</code></pre> Source code in <code>parstudio/parsers/llama_parser.py</code> <pre><code>def parse_and_export(\n    self,\n    paths: Union[str, List[str]],\n    modalities: List[str] = [\"text\", \"tables\", \"images\"],\n    **kwargs,\n) -&gt; List[ParserOutput]:\n    \"\"\"\n    Parse the given documents and export the parsed results in the specified modalities. The parsed results are exported as a ParserOutput object.\n\n    Args:\n        paths (Union[str, List[str]]): The path to the PDF file or a list of paths to the PDF files.\n        modalities (List[str]): The list of modalities to export. Default is [\"text\", \"tables\", \"images\"].\n        language (str): The language of the document. Default is \"en\".\n        result_type (str): The type of result to return. Default is \"markdown\".\n        continuous_mode (bool): Whether to use continuous mode while parsing. Default is True.\n        take_screenshot (bool): Whether to take screenshots of the document pages. Default is False.\n        disable_ocr (bool): Whether to disable OCR. Default is False.\n        is_formatting_instruction (bool): Whether to use the formatting instruction. Default is False.\n\n    Returns:\n        data (List[ParserOutput]): A list of ParserOutput objects containing the parsed results.\n\n\n    Examples:\n        &gt;&gt;&gt; parser = LlamaPDFParser()\n        &gt;&gt;&gt; data = parser.parse_and_export(\"path/to/pdf/file.pdf\", modalities=[\"text\", \"tables\", \"images\"])\n        &gt;&gt;&gt; print(data)\n        [ParserOutput(text=\"...\", tables=[...], images=[...])]\n\n    \"\"\"\n    if isinstance(paths, str):\n        paths = [paths]\n\n    if not self.initialized:\n        language = kwargs.get(\"language\", \"en\")\n        result_type = kwargs.get(\"result_type\", \"markdown\")\n        continuous_mode = kwargs.get(\"continuous_mode\", True)\n        take_screenshot = kwargs.get(\"take_screenshot\", False)\n        disable_ocr = kwargs.get(\"disable_ocr\", False)\n        is_formatting_instruction = kwargs.get(\"is_formatting_instruction\", False)\n\n        self.__initialize_llama(\n            language=language,\n            result_type=result_type,\n            continuous_mode=continuous_mode,\n            take_screenshot=take_screenshot,\n            disable_ocr=disable_ocr,\n            is_formatting_instruction=is_formatting_instruction,\n        )\n\n    data = []\n    for result in self.load_documents(paths):\n        output = self.__export_result(result, modalities)\n        data.append(output)\n\n    return data\n</code></pre>"},{"location":"parsers/pymupdf_parser/","title":"The PymuPDF Parser","text":"<p>The PymuPDF parser uses pymupdf under the hood to parse pdfs and extract text from them. It is a simple wrapper around the pymupdf library that provides a more user-friendly interface.</p>"},{"location":"parsers/pymupdf_parser/#documentation","title":"Documentation","text":""},{"location":"parsers/pymupdf_parser/#parstudio.parsers.pymupdf_parser.PyMuPDFParser","title":"<code>PyMuPDFParser</code>","text":"<p>Parse a PDF file using PyMuPDF parser.</p> Source code in <code>parstudio/parsers/pymupdf_parser.py</code> <pre><code>class PyMuPDFParser:\n    \"\"\"\n    Parse a PDF file using PyMuPDF parser.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def load_documents(paths: List[str]) -&gt; Generator[List[Page], None, None]:\n        \"\"\"\n        Load a list of PDF documents and return a generator of lists of pages.\n\n        Args:\n            paths (List[str]): List of paths to PDF files.\n\n        Returns:\n            documents (Generator[List[Page], None, None]): Generator of lists of pages.\n        \"\"\"\n        for path in paths:\n            with fitz.open(path) as doc:\n                pages = [doc.load_page(page_num) for page_num in range(doc.page_count)]\n                yield pages\n\n    def parse_and_export(\n        self,\n        paths: Union[str, List[str]],\n        modalities: List[str] = [\"text\", \"tables\", \"images\"],\n    ) -&gt; List[ParserOutput]:\n        \"\"\"\n        Parse the given documents and export the parsed results in the specified modalities. The parsed results are exported as a ParserOutput object.\n\n        Args:\n            paths (Union[str, List[str]]): The path to the PDF file or a list of paths to the PDF files.\n            modalities (List[str]): The list of modalities to export. Default is [\"text\", \"tables\", \"images\"].\n\n        Returns:\n            data (List[ParserOutput]): A list of ParserOutput objects containing the parsed results.\n\n        Examples:\n            &gt;&gt;&gt; parser = PyMuPDFParser()\n            &gt;&gt;&gt; data = parser.parse_and_export(\"path/to/pdf/file.pdf\", modalities=[\"text\", \"tables\", \"images\"])\n            &gt;&gt;&gt; print(data)\n            [ParserOutput(text=\"...\", tables=[...], images=[...])]\n        \"\"\"\n        if isinstance(paths, str):\n            paths = [paths]\n\n        data = []\n        for result in self.load_documents(paths):\n            output = self.__export_result(result, modalities)\n\n            data.append(output)\n\n        return data\n\n    def __export_result(self, pages: List[Page], modalities: List[str]) -&gt; ParserOutput:\n        \"\"\"\n        Export the parsed results in a ParserOutput object for the given document.\n\n        Args:\n            pages (List[Page]): List of pages of the document.\n            modalities (List[str]): List of modalities to export.\n\n        Returns:\n            output (ParserOutput): ParserOutput object containing the parsed results.\n        \"\"\"\n        text = \"\"\n        tables: List[Dict] = []\n        images: List[Dict] = []\n\n        for page in pages:\n            if \"text\" in modalities:\n                text += self._extract_text(page) + \"\\n\"\n\n            if \"tables\" in modalities:\n                tables += self._extract_tables(page)\n\n            if \"images\" in modalities:\n                images += self._extract_images(page)\n\n        return ParserOutput(text=text, tables=tables, images=images)\n\n    @staticmethod\n    def _extract_text(page: Page) -&gt; str:\n        \"\"\"\n        Extract text from a page.\n\n        Args:\n            page (Page): The page object to extract text from.\n\n        Returns:\n            text (str): The extracted text from the page.\n        \"\"\"\n        return page.get_text(\"text\")\n\n    @staticmethod\n    def _extract_images(page: Page) -&gt; List[Dict]:\n        \"\"\"\n        Extract images from the document and return as a list of dictionaries with image data.\n\n        Args:\n            page (Page): The page object to extract images from.\n\n        Returns:\n            images (List[Dict]): A list of dictionaries containing image data.\n            Each dictionary contains the image data as a PIL Image object.\n        \"\"\"\n        images = []\n        for img in page.get_images(full=True):\n            xref = img[0]\n            base_image = page.parent.extract_image(xref)\n            img_data = BytesIO(base_image[\"image\"])\n            image = Image.open(img_data).convert(\"RGB\")\n            images.append({\"image\": image})\n        return images\n\n    @staticmethod\n    def _extract_tables(page: Page) -&gt; List[Dict]:\n        \"\"\"\n        Extract tables from the document and return as a list of dictionaries with table markdown and dataframe data.\n\n        Args:\n            page (Page): The page object to extract tables from.\n\n        Returns:\n            tables (List[Dict]): A list of dictionaries with table data.\n            Each dictionary contains a markdown table (table_md) and a pandas dataframe (table_df).\n        \"\"\"\n\n        tabs = page.find_tables()\n\n        tables = []\n        for tab in tabs:\n            tables.append({\"table_md\": tab.to_markdown(), \"table_df\": tab.to_pandas()})\n\n        return tables\n</code></pre>"},{"location":"parsers/pymupdf_parser/#parstudio.parsers.pymupdf_parser.PyMuPDFParser.__export_result","title":"<code>__export_result(pages, modalities)</code>","text":"<p>Export the parsed results in a ParserOutput object for the given document.</p> <p>Parameters:</p> Name Type Description Default <code>pages</code> <code>List[Page]</code> <p>List of pages of the document.</p> required <code>modalities</code> <code>List[str]</code> <p>List of modalities to export.</p> required <p>Returns:</p> Name Type Description <code>output</code> <code>ParserOutput</code> <p>ParserOutput object containing the parsed results.</p> Source code in <code>parstudio/parsers/pymupdf_parser.py</code> <pre><code>def __export_result(self, pages: List[Page], modalities: List[str]) -&gt; ParserOutput:\n    \"\"\"\n    Export the parsed results in a ParserOutput object for the given document.\n\n    Args:\n        pages (List[Page]): List of pages of the document.\n        modalities (List[str]): List of modalities to export.\n\n    Returns:\n        output (ParserOutput): ParserOutput object containing the parsed results.\n    \"\"\"\n    text = \"\"\n    tables: List[Dict] = []\n    images: List[Dict] = []\n\n    for page in pages:\n        if \"text\" in modalities:\n            text += self._extract_text(page) + \"\\n\"\n\n        if \"tables\" in modalities:\n            tables += self._extract_tables(page)\n\n        if \"images\" in modalities:\n            images += self._extract_images(page)\n\n    return ParserOutput(text=text, tables=tables, images=images)\n</code></pre>"},{"location":"parsers/pymupdf_parser/#parstudio.parsers.pymupdf_parser.PyMuPDFParser.load_documents","title":"<code>load_documents(paths)</code>  <code>staticmethod</code>","text":"<p>Load a list of PDF documents and return a generator of lists of pages.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>List[str]</code> <p>List of paths to PDF files.</p> required <p>Returns:</p> Name Type Description <code>documents</code> <code>Generator[List[Page], None, None]</code> <p>Generator of lists of pages.</p> Source code in <code>parstudio/parsers/pymupdf_parser.py</code> <pre><code>@staticmethod\ndef load_documents(paths: List[str]) -&gt; Generator[List[Page], None, None]:\n    \"\"\"\n    Load a list of PDF documents and return a generator of lists of pages.\n\n    Args:\n        paths (List[str]): List of paths to PDF files.\n\n    Returns:\n        documents (Generator[List[Page], None, None]): Generator of lists of pages.\n    \"\"\"\n    for path in paths:\n        with fitz.open(path) as doc:\n            pages = [doc.load_page(page_num) for page_num in range(doc.page_count)]\n            yield pages\n</code></pre>"},{"location":"parsers/pymupdf_parser/#parstudio.parsers.pymupdf_parser.PyMuPDFParser.parse_and_export","title":"<code>parse_and_export(paths, modalities=['text', 'tables', 'images'])</code>","text":"<p>Parse the given documents and export the parsed results in the specified modalities. The parsed results are exported as a ParserOutput object.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>Union[str, List[str]]</code> <p>The path to the PDF file or a list of paths to the PDF files.</p> required <code>modalities</code> <code>List[str]</code> <p>The list of modalities to export. Default is [\"text\", \"tables\", \"images\"].</p> <code>['text', 'tables', 'images']</code> <p>Returns:</p> Name Type Description <code>data</code> <code>List[ParserOutput]</code> <p>A list of ParserOutput objects containing the parsed results.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; parser = PyMuPDFParser()\n&gt;&gt;&gt; data = parser.parse_and_export(\"path/to/pdf/file.pdf\", modalities=[\"text\", \"tables\", \"images\"])\n&gt;&gt;&gt; print(data)\n[ParserOutput(text=\"...\", tables=[...], images=[...])]\n</code></pre> Source code in <code>parstudio/parsers/pymupdf_parser.py</code> <pre><code>def parse_and_export(\n    self,\n    paths: Union[str, List[str]],\n    modalities: List[str] = [\"text\", \"tables\", \"images\"],\n) -&gt; List[ParserOutput]:\n    \"\"\"\n    Parse the given documents and export the parsed results in the specified modalities. The parsed results are exported as a ParserOutput object.\n\n    Args:\n        paths (Union[str, List[str]]): The path to the PDF file or a list of paths to the PDF files.\n        modalities (List[str]): The list of modalities to export. Default is [\"text\", \"tables\", \"images\"].\n\n    Returns:\n        data (List[ParserOutput]): A list of ParserOutput objects containing the parsed results.\n\n    Examples:\n        &gt;&gt;&gt; parser = PyMuPDFParser()\n        &gt;&gt;&gt; data = parser.parse_and_export(\"path/to/pdf/file.pdf\", modalities=[\"text\", \"tables\", \"images\"])\n        &gt;&gt;&gt; print(data)\n        [ParserOutput(text=\"...\", tables=[...], images=[...])]\n    \"\"\"\n    if isinstance(paths, str):\n        paths = [paths]\n\n    data = []\n    for result in self.load_documents(paths):\n        output = self.__export_result(result, modalities)\n\n        data.append(output)\n\n    return data\n</code></pre>"}]}